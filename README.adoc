= Crux Corda
:toc:
:toc-placement: preamble
:toclevels: 2


A library that allows you to pipe verified https://docs.corda.net/docs/corda-os/4.8/api-transactions.html[Corda transactions] into a https://opencrux.com[Crux] node, to then query using Crux's bitemporal Datalog query engine.We recommend you read our https://juxt.pro/blog/on-bridging-databases-and-blockchain[featured blog post "On bridging blockchain and databases"] to learn more about the background for this library.

== Corda 101

https://www.corda.net/[Corda] is a blockchain development platform. It embraces a permissioned distributed ledger model based on Public Key Infrastructure.

It is primarily written in https://kotlinlang.org/[Kotlin], a member of the JVM family of languages.

https://docs.corda.net/docs/corda-os/4.8/cordapp-overview.html[CordDApps] (Corda Distributed Applications) are distributed applications that run on the Corda platform. The goal of a CorDapp is to allow nodes to reach agreement on updates to the ledger. They achieve this goal by defining flows that Corda node owners can invoke over RPC.

== Requirements

If you already run a CorDApp and are looking to integrate Crux as a new feature, feel free to skip this section.

If you are new to Corda, we recommend going through the following material:

. https://docs.corda.net/docs/corda-os/4.8/key-concepts.html[Key Concepts]. In particular *States*, *Flows*, and *Transactions*
. Going over the https://docs.corda.net/docs/corda-os/4.7/hello-world-introduction.html[Hello World tutorial]
. https://docs.corda.net/docs/corda-os/4.8/node-services.html[The Service Hub], not essential but a good troubleshooting reference

== Preparing your CorDApp to use `crux-corda`

Flows can't query Crux out of the box. In order to integrate `crux-corda`

. A `CruxState` object must be passed to `crux-corda` so it can be piped into Crux. The simplest way to go about it is letting your existing States implement `CruxState`.
. Register Crux with Corda's ServiceHub.
. Optionally, we can write a function that filters or transforms a State validated by Corda before it is passed to `Crux`.

image::https://juxt-resources.netlify.app/img/crux-corda-diag.png["Flow diagram",width=700]

We will use the *IOU CorDApp* to further illustrate the setup.

=== Getting Started

WARNING: This project is still in an experimental phase. It has not been uploaded to Maven.

NOTE: This section assumes you are on a Corda Project, eg. `IOU CorDApp` from the https://docs.corda.net/docs/corda-os/4.7/hello-world-introduction.html[Hello World tutorial], and using Gradle as a build tool.

Start by cloning this repo. Locate the `crux-corda` and `crux-corda-state` directories within. Copy them into your project root, and let Gradle know about them in `settings.gradle.kts`.

[source,kotlin]
----
// ...
include("crux-corda-state", "crux-corda", ....)
----

This way you can later reference them as project dependencies in a `build.gradle.kts`. Don't forget to include `crux` as well.

[source,kotlin]
----
dependencies{
    // ...
    implementation("pro.juxt.crux", "crux-core", "1.17.1-rc1")
    cordapp(project(":crux-corda-state"))
    cordapp(project(":crux-corda"))
    // ...
}

----

=== Implement the CruxState interface

States in Corda have a schema and live in memory as Objects. Crux in contrast deals with schemaless EAV triples.

In order for `crux-corda` can only consume `CruxState` objects.

.link:/iou-contract/src/main/kotlin/com/example/contract/IOUState.kt[] - example of a Corda state with a Crux mapping
[source,kotlin]
----
@BelongsToContract(IOUContract::class)
data class IOUState(val value: Int,
                    val lender: Party,
                    val borrower: Party,
                    override val linearId: UniqueIdentifier = UniqueIdentifier()) :
    LinearState, CruxState {

    override val cruxId = linearId.id
    override val cruxDoc: Map<String, Any> = mapOf(
        "iou-state/value" to value,
        "iou-state/lender" to lender.name.toString(),
        "iou-state/borrower" to borrower.name.toString())
}
----

=== Configure and Run Crux in the Service Hub

.In order to run Crux, register a new node like so
[source,kotlin]
----
@CordaService
class CruxService(private val serviceHub: AppServiceHub) : SingletonSerializableAsToken() {
    val node = serviceHub.startCruxNode()
}
----

By default, https://opencrux.com/reference/20.09-1.12.1/configuration.html[the Crux API] starts an in-memory node.

WARNING: The only constraint to Crux's node configuration in this case is *you must use the custom Corda Tx Log*.
By importing `crux-corda` as a dependency, the Crux API is automatically extended with the Corda Tx Log, as well as setting it up as default

.Here is how to configure its behaviour. By default, any validated CruxState is piped into Crux as shown below.
[source,kotlin]
----
val node = serviceHub.startCruxNode {
    withCordaTxLog {
        withDocumentMapping { doc ->
            if (doc is CruxState) listOf(doc)
            else null
        }
    }
}
----

== Querying Crux

Since we are running a real Crux node, we can refer to the https://opencrux.com/reference/20.09-1.12.1/queries.html[Queries API] directly once we grab onto a Crux node reference.

[source,kotlin]
----
val cruxNode = serviceHub.cordaService(CruxService::class.java)

cruxNode.db().query("""
    {:find [?l ?b ?v]
     :where [[?iou :iou-state/lender ?l]
             [?iou :iou-state/borrower ?b]
             [?iou :iou-state/value ?v]]}
    """.trimIndent())
----

TIP: Keep in mind the Crux database is not global, but local to each Corda node. You can't query facts that have happened in other nodes unless explicitly shared with yours through a Corda Flow.

== Examples

This repo contains a more elaborate example app that builds on top of the https://docs.corda.net/docs/corda-os/4.7/hello-world-introduction.html[Hello World tutorial].

We will limit ourselves to running our app inside tests by Mocking the network, as well as the Corda nodes. Should you want to run real nodes, follow the https://docs.corda.net/docs/corda-os/4.8/run-your-cordapp.html[tutorial on the subject].

Make sure you can run the `crux-corda:iou-workflow` tests either from your IDE or from the command line with `./gradlew -p iou-workflow test` from the project root.

There's a total of 3 tests in `com.example.workflow.IOUFlowTests`.

=== `flow records the correct IOU in both parties' vaults`
We create an `IOUState` between nodes A and B. Since `IOUState` has been modified to implement `CruxState` in addition to `LinearState`, the `CruxService` on each node was able to pick up the transaction

.We can verify this by issuing a Crux Query
[source,kotlin]
----
assertEquals(
    listOf(a.info.singleIdentity().name.toString(), b.info.singleIdentity().name.toString(), 1L),
    cruxNode.db().query("""
        {:find [?l ?b ?v]
         :where [[?iou :iou-state/lender ?l]
                 [?iou :iou-state/borrower ?b]
                 [?iou :iou-state/value ?v]]}""".trimIndent())
        .first()
)
----

.We can also verify that, at different points in time, the query returns the same result for a database value in the future, and no results for a database value in the past
[source,kotlin]
----
// Crux knows about the transaction three days from now
assertEquals(
    listOf(a.info.singleIdentity().name.toString(), b.info.singleIdentity().name.toString(), 1L),
    cruxNode.db(inThreeDays).query("""
        {:find [?l ?b ?v]
         :where [[?iou :iou-state/lender ?l]
                 [?iou :iou-state/borrower ?b]
                 [?iou :iou-state/value ?v]]}""".trimIndent()).first()
)
// Crux does not know about the transaction three days ago
assertEquals(
    emptySet(),
    cruxNode.db(threeDaysAgo).query("""
        {:find [?l ?b ?v]
         :where [[?iou :iou-state/lender ?l]
                 [?iou :iou-state/borrower ?b]
                 [?iou :iou-state/value ?v]]}"""
            .trimIndent())
)
----

=== `A lends money to B, B buys a "house"`

We introduce a new State class - `com.example.contract.ItemState`. An item has a name, a value, and an owner. The owner of the item - a Corda Node - is the only party aware of the state.
`com.example.workflow.ItemFlow` defines how to create a new `ItemState`. The catch is in order to create a new `ItemState` with a transaction, the Party needs to have a positive balance.

.The balance depends on the money lent, borrowed, as well as other items' value. It is calculated as follows:
----
balance = money_borrowed - money_lent - owned_items_value
----

.We can calculate these values with a Crux query each.
[source,kotlin]
----
val money_borrowed = currentDb.query("""
        {:find [(sum ?v)]
         :in [?b]
         :where [[?iou :iou-state/borrower ?b]
                 [?iou :iou-state/value ?v]]}
""".trimIndent(), me.name.toString()).singleOrNull()?.singleOrNull() as Long? ?: 0

val money_lent = currentDb.query("""
        {:find [(sum ?v)]
         :in [?l]
         :where [[?iou :iou-state/lender ?l]
                 [?iou :iou-state/value ?v]]}
""".trimIndent(), me.name.toString()).singleOrNull()?.singleOrNull() as Long? ?: 0

val owned_items_value = currentDb.query("""
        {:find [(sum ?v)]
         :in [?o]
         :where [[?item :item/owner ?o]
                 [?item :item/value ?v]]}
""".trimIndent(), me.name.toString()).singleOrNull()?.singleOrNull() as Long? ?: 0
----

If we try to initiate an `ItemFlow` with a balance lesser than the value of the item, the flow throws an exception.

As the test describes, we start by lending B enough money to buy an item. B can then start an `ItemFlow` to create an `ItemState`.

.The query that follows exemplifies how, starting with a particular lender, we can retrieve all items that have been acquired by its borrowers, effectively turning 2 Corda vault queries into 1.
[source,kotlin]
----
assertEquals(
        listOf("house", 3L),
        newDb.query("""
            {:find [?name ?value]
             :in [?lender]
             :where [[?iou :iou-state/borrower ?borrower]
                     [?iou :iou-state/lender ?lender]
                     [?item :item/owner ?borrower]
                     [?item :item/name ?name]
                     [?item :item/value ?value]]}
    """.trimIndent(), a.info.singleIdentity().name.toString()).single())
----

=== `A lends 10 to B, then B lends 20 to A, resulting in A owing 10`

We modified `com.example.workflow.IOUFlow` and `com.example.contract.IOUContract` by allowing not only the creation of an `IOUState`, but its update. The updated flow dictate there can only be one active IOU statement between the same 2 parties. When a new `IOUFlow` is started by a node, we first fetch any existing `UNCONSUMED` `IOUState` between both parties.

If none such state exists, we proceed as previously by creating a new state. In case there already exists one, we use it as an input to the new `Commands.UpdateIOU` in `IOUContract`. The new `IOUState.value` is calculated based on who is lending / borrowing, as well as the role of each party.

At the end of the test, two Crux queries help us verify that

. After the update, the roles have been reversed
+
[source,kotlin]
----
// After the first transaction, B owes A money
assertEquals(
        listOf(10L, aId.toString(), bId.toString()),
        firstDB.query("""
            {:find [?v ?l ?b]
             :where [[?iou :iou-state/borrower ?b]
                     [?iou :iou-state/lender ?l]
                     [?iou :iou-state/value ?v]]}
        """.trimIndent()).single())

// After the second transaction, A owes B money
assertEquals(
        listOf(10L, bId.toString(), aId.toString()),
        secondDB.query("""
            {:find [?v ?l ?b]
             :where [[?iou :iou-state/borrower ?b]
                     [?iou :iou-state/lender ?l]
                     [?iou :iou-state/value ?v]]}
        """.trimIndent()).single())
----
. Both versions of the Crux database see the same entity being updated, which is exactly what happened from Corda's point of view as well
+
[source,kotlin]
----
// It is the same CRUX fact too
assertEquals(
        firstDB.query("""
            {:find [?id]
             :in [?l]
             :where [[?iou :crux.db/id ?id]
                     [?iou :iou-state/lender ?l]]}
        """.trimIndent(), aId.toString()),
        secondDB.query("""
            {:find [?id]
             :in [?b]
             :where [[?iou :crux.db/id ?id]
                     [?iou :iou-state/borrower ?b]]}
        """.trimIndent(), aId.toString())
----

=== `A lends 10 to B, but then retracts and deletes the IOU`

In order for this test to run, we implemented the deletion of an `IOUState` by writing a new flow class `com.example.workflow.IOUFlow.DeleteIOUFlow`. We record the time at which A lends money to B and demonstrate Crux is able to keep up with deletions, and remember historical facts too.

[source,kotlin]
----
// After the first transaction, B owes A money
assertEquals(
        listOf(10L, aId.toString(), bId.toString()),
        firstDB.query("""
            {:find [?v ?l ?b]
             :where [[?iou :iou-state/borrower ?b]
                     [?iou :iou-state/lender ?l]
                     [?iou :iou-state/value ?v]]}
        """.trimIndent()).single())

// After the second transaction, no facts are visible
assertEquals(
        emptySet(),
        secondDB.query("""
            {:find [?v ?l ?b]
             :where [[?iou :iou-state/borrower ?b]
                     [?iou :iou-state/lender ?l]
                     [?iou :iou-state/value ?v]]}
        """.trimIndent()))
----

== Limitations

Some limitations are conceptual, due to the nature of Corda and its integration with Crux. Others are technical, and can possibly be implemented in future feature releases.

=== Conceptual

Conceptual limitations revolve around the fact Corda drives the data lifecycle, and some concepts / operations native to Crux are missing in Corda.

* *The `crux.db/submit-tx` API is unavailable.*
+
One would immediately break the pairing between Corda's Vault, and Crux's document store.
* *Eviction - `:crux.tx/evict` - is not possible.*
+
This operation does not exist in Corda.
* *The past/future can't be modified.*
+
Corda registers events at the time they occur in the ledger.

=== Technical

* https://github.com/juxt/crux-corda/issues/3[Issue#3]: In order to fetch a `StateAndRef` object to use as input for a new transaction, one must use Corda's `net.corda.core.node.services.VaultService`. Ideally, `crux-corda` would provide an API to obtain this object, so that the user can use `CruxService`'s queries only.
+
Currently, this is the recommended way to obtain StateAndRef objects that have not yet been consumed - i.e. their latest version
[source,kotlin]
----
serviceHub.vaultService.queryBy<IOUState>(QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED)).states.filter {
    // optionally filter states based on some criteria
}
----

== Licence

The MIT License (MIT)

Copyright © 2020-2021 JUXT LTD.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
